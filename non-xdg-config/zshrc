# =============================================================================
# Changing Directories
# =============================================================================

# If a command is issued that can't be executed as a normal command, and the
# command is the name of a directory, perform the cd command to that directory.
setopt auto_cd

# Make cd push the old directory onto the directory stack.
setopt auto_pushd

# Don't push multiple copies of the same directory onto the directory stack.
setopt pushd_ignore_dups

# =============================================================================
# History
# =============================================================================

# If the internal history needs to be trimmed to add the current command line,
# setting this option will cause the oldest history event that has a duplicate
# to be lost before losing a unique event from the list.
setopt hist_expire_dups_first

# When searching for history entries in the line editor, do not display
# duplicates of a line previously found, even if the duplicates are not
# contiguous.
setopt hist_find_no_dups

# Do not enter command lines into the history list if they are duplicates of the
# previous event.
setopt hist_ignore_dups

# Append command to history file immediately after execution
setopt INC_APPEND_HISTORY_TIME

unsetopt BEEP

WORDCHARS='*?_-.[]~=/&;!#$%^(){}<>'

part-delete() {
local WORDCHARS='*?[]~=&;!#$%^(){}<>'
zle backward-delete-word
}
zle -N part-delete
bindkey "\e^?" part-delete

sudo-command-line() {
[[ -z $BUFFER ]] && zle up-history
if [[ $BUFFER == sudo\ * ]]; then
    LBUFFER="${LBUFFER#sudo }"
else
    LBUFFER="sudo $LBUFFER"
fi
}
zle -N sudo-command-line

bindkey "\es" sudo-command-line

_dircycle_update_cycled() {
    setopt localoptions nopushdminus

    [[ ${#dirstack} -eq 0 ]] && return 1

    while ! builtin pushd -q $1 &>/dev/null; do
        # A missing directory was found; pop it out of the directory stack.
        builtin popd -q $1

        # Stop trying if there are no more directories in the directory stack.
        [[ ${#dirstack} -eq 0 ]] && return 1
    done
    if (( $? == 0 )); then
        local precmd
        for precmd in $precmd_functions; do
            $precmd
        done
        zle reset-prompt
    fi
}

_dircycle_insert_cycled_left() {
    if [[ -n $BUFFER ]]; then
local WORDCHARS='*?[]~=&;!#$%^(){}<>'
        zle backward-word
    else
    _dircycle_update_cycled +1 || return
    fi
}
zle -N _dircycle_insert_cycled_left

_dircycle_insert_cycled_right() {
    if [[ -n $BUFFER ]]; then
local WORDCHARS='*?[]~=&;!#$%^(){}<>'
        zle forward-word
    else
    _dircycle_update_cycled -0 || return
    fi
}
zle -N _dircycle_insert_cycled_right

bindkey "\e[1;3C" _dircycle_insert_cycled_right
bindkey "\e[1;3D" _dircycle_insert_cycled_left

pipe_to_pager() {
[[ -z $BUFFER ]] && zle up-history
BUFFER="$BUFFER |& less"
}
zle -N pipe_to_pager

bindkey "\ep" pipe_to_pager

bindkey "\e/" redo

bindkey "\e[1;2D" backward-word
bindkey "\e[1;2C" forward-word

alias v="nvim"

if type brew &>/dev/null
then
  FPATH="$(brew --prefix)/share/zsh/site-functions:${FPATH}"
fi

  # autoload -Uz compinit
  # compinit

# set list-colors to enable filename colorizing
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
# setopt nolistambiguous
# fuzzy matching mode
zstyle ':completion:*' matcher-list '' \
  'm:{[:lower:]}={[:upper:]}' \
  'r:|=*' 'l:|=* r:|=*' \
  'm:{[:lower:]}={[:upper:]} r:|=*' \
  'm:{[:lower:]}={[:upper:]} l:|=* r:|=*' \
  'r:|?=**' \
  'm:{[:lower:]}={[:upper:]} r:|?=**'

ZSH_AUTOSUGGEST_STRATEGY=(history completion)

path+=~/Library/Python/3.8/bin/
export PATH

export EDITOR=nvim
export VISUAL=nvim
export LANG=en_GB.UTF-8
export MANPAGER='nvim +Man!'

# zmodload -i zsh/complist
# zle -C complete-word menu-select complete-word

# bindkey -M menuselect '^[[Z' reverse-menu-complete

# complete-word() {
#   _main_complete;
#   compstate[list]='list';
#   local word=$PREFIX$SUFFIX
#   (( compstate[unambiguous_cursor] <= ${#word} )) && compstate[insert]='menu';
# }

zstyle ':autocomplete:*' insert-unambiguous true
zstyle ':autocomplete:*' widget-style menu-select
zstyle ':autocomplete:*' min-input 2

# autoload -Uz up-line-or-beginning-search down-line-or-beginning-search
# zle -N up-line-or-beginning-search
# zle -N down-line-or-beginning-search

# bindkey '^[[A' up-line-or-beginning-search
# bindkey '^[[B' down-line-or-beginning-search

# source ~/zsh/fzf-tab/fzf-tab.zsh
source ~/zsh/zsh-autocomplete/zsh-autocomplete.plugin.zsh
source ~/zsh/fsh/fast-syntax-highlighting.plugin.zsh
# source ~/zsh/zsh-autosuggestions/zsh-autosuggestions.zsh
# source ~/zsh/zsh-history-substring-search/zsh-history-substring-search.zsh
source ~/zsh/git-prompt.zsh/git-prompt.zsh

notify_precmd()
{
        if [[ -n $TIMESTAMP ]]; then
        res=$((SECONDS-TIMESTAMP))
        if [ $res -ge 0 ]; then
        if [[ $(lsappinfo info -only bundleID "$(lsappinfo front)" | cut -d '"' -f4) != net.kovidgoyal.kitty ]]; then
            cmd=$(fc -ln -1)
            notification "$cmd" "Finished in $res seconds"
        fi
        fi
    fi
}

notify_preexec()
{
    TIMESTAMP=$SECONDS
}

notification(){
    osascript -e "display notification \"$2\" with title \"$1\""
}

autoload -Uz add-zsh-hook
add-zsh-hook preexec notify_preexec
add-zsh-hook precmd notify_precmd

# Theming variables for primary prompt
ZSH_THEME_GIT_PROMPT_PREFIX=""
ZSH_THEME_GIT_PROMPT_SUFFIX=" "
ZSH_THEME_GIT_PROMPT_SEPARATOR=" "
ZSH_THEME_GIT_PROMPT_BRANCH="%{$fg[green]%}"
ZSH_THEME_GIT_PROMPT_UNSTAGED="%{$fg[cyan]%}✚"
ZSH_THEME_GIT_PROMPT_CLEAN="%{$fg[green]%}✔"

PROMPT='
%F{blue}%40<..<%~ $(gitprompt)'
PROMPT+='%(?.%(!.%F{yellow}.%F{green}).%F{red}[%B${"${pipestatus[*]}"// /|}%b])❯%f '

function edit-command-line-inplace() {
  if [[ $CONTEXT != start ]]; then
    if (( ! ${+widgets[edit-command-line]} )); then
      autoload -Uz edit-command-line
      zle -N edit-command-line
    fi
    zle edit-command-line
    return
  fi
  () {
    emulate -L zsh -o nomultibyte
    local editor=("${(@Q)${(z)${VISUAL:-${EDITOR:-vi}}}}")
    case $editor in
      (*vim*)
        "${(@)editor}" -c "normal! $(($#LBUFFER + 1))go" -- $1
      ;;
      (*emacs*)
        local lines=("${(@f)LBUFFER}")
        "${(@)editor}" +${#lines}:$((${#lines[-1]} + 1)) $1
      ;;
      (*)
        "${(@)editor}" $1
      ;;
    esac
    BUFFER=$(<$1)
    CURSOR=$#BUFFER
  } =(<<<"$BUFFER") </dev/tty
}

zle -N edit-command-line-inplace
bindkey '\C-x\C-e' edit-command-line-inplace
